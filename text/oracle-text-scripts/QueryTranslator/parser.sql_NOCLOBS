--TODO:  rationalize clob versus varchar
--TODO:  handle buffer overflow in proximQuery
--TODO:  add index name and join chars
--TODO:  add "default AND" : DONE??
--TODO:  validate sections?
--TODO:  allow single word section searches eg title:dog : NO - too complicated, hard to find end of word
--TODO:  allTermsRequired should be global like other options
--TODO:   select * from avtest where contains(text, parser.progrelax('cat +seca:(dog rabbit)'),1) > 0; - why do we see dog & rabbit inside section search?
--TODO:  phrase search pointless if only one simple term
--TODO:   select * from avtest where contains(text, parser.progrelax('seca:(dog rabbit)'),1) > 0 _> fails
--TODO:  to allow nested section replace createQueryTerms in parseSection with splitSection ??
--TODO: fix up allTerms= true in simpleQuery
--TODO: remove all dbms_output lines


set serverout on size 1000000
set define off

create or replace package parser is

scoreTypeInteger integer := 0;
scoreTypeFloat   integer := 1;

optionFalse      integer := 0;
optionTrue       integer := 1;

function  simpleSearch     ( inStr varchar2 ) return varchar2;
function  phraseSearch     ( inStr varchar2 ) return varchar2;
function  nearSearch       ( inStr varchar2 ) return varchar2;
function  proximSearch     ( inStr varchar2 ) return varchar2;
function  andSearch        ( inStr varchar2 ) return varchar2;
function  accumSearch      ( inStr varchar2 ) return varchar2;
function  progRelax        ( inStr varchar2 ) return varchar2;

procedure SetScoreType     (scoreType integer);
procedure UseNEAR2         (near2Option integer);
procedure SetWildcard      (wildcard varchar2);
procedure SetMinusOnlyFail (failOption integer);

-- Public variables
allTermsRequired  boolean := FALSE;

end parser;
/
--list
show errors

create or replace package body parser is

-- datatype used internally in this package

type exprList is table of varchar2(4000);

type queryTerms is record (
  allTerms    exprList ,   -- all the non-section terms, in the order specified
  reqTerms    exprList ,   -- these MUST be present, may include sections
  optTerms    exprList ,   -- these CAN be present, may include sections
  negTerms    exprList     -- these MUST NOT be present
);

type wordListType is table of varchar2(64);

-- Global variables

global_scoreType varchar2(20) default 'INTEGER';
global_nearOper  varchar2(5)  default 'NEAR';
global_wildCard  varchar2(1)  default '*';
global_stopList  wordListType;
global_failMinus boolean      default FALSE;

-- find the first regexp in a string, return string with that 
-- regexp removed, and the match itself

procedure regexp_next_match 
  (str in out varchar2, match out varchar2, pattern varchar2) 
is
  rest    varchar2(32767) := str;
  newstart integer;
begin
     match := regexp_substr(rest, pattern, 1, 1, 'n');
     newStart := regexp_instr(rest, pattern, 1, 1, 1, 'n');
     str := substr(rest, newstart, length(rest)-newstart+1);
end;

-- parse a string into words consisting of alphunumerics, optional join characters
-- and optional single leading and trailing wildchars. Double quotes surrounding 
-- multiple word will treat them as a single one

-- todo: move joinchars etc to globals

-- Handle a unary minus : eg "-oracle" with no other terms

procedure handleUnaryMinus is
begin
  if global_failMinus then
    raise_application_error(-20704, 'cannot have a NOT term on its own: you must have other terms'); 
  end if;
end handleUnaryMinus;

-- Check whether word is in stopword list

function notStopWord (testWord varchar2) return boolean is
  i integer;
  w varchar2(256);
begin
  -- strip any braces
  w := testWord;
  w := replace(w, '{', '');
  w := replace(w, '}', '');

  if global_stoplist is null or global_stopList.count() = 0 then
    return true;
  end if;
  for i in 1 .. global_stopList.last loop
    --p('comparing '''|| w ||''' against '''||global_stopList(i)||'''');
    if lower(w) = lower(global_stopList(i)) then
      return false;
    end if;
  end loop;
  return true;
end;

procedure reParse (
   userStr   in  varchar2, 
   words     out wordListType, 
   joinChars in  varchar2 default '',
   leadChars in  varchar2 default '+-',
   userWild  in  varchar2 default '*',
   sysWild   in  varchar2 default '%') 
is
  str       varchar2(32767) := userStr;
  pattern   varchar2(2000);
  match     varchar2(2000);
  i         integer;
  lc        varchar2(128);
  ec        varchar2(128);
  joinC     varchar2(128) := joinChars; -- local copy for editing
  jc1       varchar2(128) := '';        -- special position join chars
  jc2       varchar2(128) := '';
  jc3       varchar2(128) := '';
begin

  --p('reParse: str is ' || str);

  if length(leadChars) > 0  then
    lc := '['||leadChars||']?';
  else
    lc := '';
  end if;

  if length(userWild) > 0 then
    ec := '['||userWild||']?';
  else
    ec := '';
  end if;

  -- Posix regular expressions do not allow escaping of characters in 
  -- bracketed strings. If a join character is "]", it MUST appear as
  -- the first character. "^" can appear anywhere BUT first, "-" MUST
  -- appear at the end. That's what I call programmer unfriendly.

  if instr (joinC, ']') > 0 then
    jc1 := ']';
    joinC := replace (joinC, ']', '');
  end if;

  if instr (joinC, '[') > 0 then
    jc1 := jc1 || '[';
    joinC := replace (joinC, '[', '');
  end if;

  if instr (joinC, '^') > 0 then
    jc2 := '^';
    joinC := replace (joinC, '^', '');
  end if;

  if instr (joinC, '-') > 0 then
    jc3 := '-';
    joinC := replace (joinC, '-', '');
  end if;

  pattern := '(' || lc || '[' || jc1 || '[:alnum:]' || joinC || jc2 || jc3 || ']+' || ec ||
              ')|(' || lc || '".+")';
  --p(pattern);

  words := wordListType();
  loop
    regexp_next_match (str, match, pattern);

    -- deal specially with quoted strings: we need to remove the quotes
    -- and any non-alpha/numeric/join chars, except for + at beginning

    if regexp_instr (match, '^' || lc || '"') > 0 then
       -- remove the quotes, leaving any leading plus
       match := regexp_replace (match, '^('|| lc || ')"(.+)"$', '\1\2');

       -- remove any unwanted chars except + at the start
       if instr (leadChars, substr (match, 1, 1)) > 0 then  
         match := regexp_replace (match, '[^'||jc1||'[:space:][:alnum:]'||joinC||jc2||jc3||']+', ' ', 2);
       else
         match := regexp_replace (match, '[^[:space:][:alnum:]'||joinC||jc2||jc3||']+', ' ');
       end if;
 
       -- squash down multiple spaces
       match := regexp_replace (match, '[[:space:]]+', ' ');
    end if;

    exit when match is null or length(match) = 0;

    -- translate wild card and escape joinchars
    -- OR surround word with braces (braces don't work with wild cards,
    -- backslashes don't escape keywords)

    if substr(match, length(match), 1) = userWild then
       match := substr(match, 1, length(match)-1);
       if length(joinChars) > 0 then
         match := regexp_replace (match, '(['||jc1||joinC||jc2||jc3||'])', '\\\1'); 
       end if;
       match := match || sysWild;
    else
       match := regexp_replace (match, '^('||lc||')(.*)', '\1{\2}');
    end if;

    --p('adding new word '||match);
    words.extend(1);

    words(words.last()) := match;
    --p('Word: <'||match||'>');
    exit when str is null or length(str) = 0;
  end loop;

end reParse;

-- given a string (subquery), parse it into a queryTerms record
-- qTerms must be initialized before calling this

procedure createQueryTerms (
 queryString in            varchar2, 
 qTerms      in out nocopy queryTerms,
 clear       in            boolean default false
) is
  words     wordListType;
  firstChar varchar2(1);
  allT   exprList;
  reqT   exprList;
  optT   exprList;
  negT   exprList;
begin

  -- Initialise the table if not already done
  if qterms.allTerms is null or clear then
    --dbms_output.put_line('Initializing qterms');
    allT := exprList();
    reqT := exprList();
    optT := exprList();
    negT := exprList();
    qTerms.allTerms := allT;
    qTerms.reqTerms := reqT;
    qTerms.optTerms := optT;
    qTerms.negTerms := negT;
  end if;

  --dbms_output.put_line('in createQueryTerms');
  reParse (queryString, words);

  for i in 1 .. words.count() loop
    firstChar := substr( words(i), 1, 1 );
    case firstChar
      when '+' then
        qTerms.allTerms.extend(1);
        qTerms.allTerms(qTerms.allTerms.last()) := substr( words(i), 2);   
        qTerms.reqTerms.extend(1);
        qTerms.reqTerms(qTerms.reqTerms.last()) := substr( words(i), 2);   
      when '-' then
        qTerms.negTerms.extend(1);
        qTerms.negTerms(qTerms.negTerms.last()) := substr( words(i), 2);   
      else
        qTerms.allTerms.extend(1);
        qTerms.allTerms(qTerms.allTerms.last()) := substr( words(i), 1);   
        qTerms.optTerms.extend(1);
        qTerms.optTerms(qTerms.optTerms.last()) := substr( words(i), 1);   
        --dbms_output.put_line('adding opt term ' || substr( words(i), 1));
    end case;
  end loop;

end createQueryTerms;

-- take a section search such as title:(foo bar) and return a queryTerms object
-- and the section name

procedure parseSection (
  str     in            varchar2, 
  qterms  in out nocopy queryTerms, 
  secName in out nocopy varchar2
) is
  pos     integer;
  re      varchar2(30) := '[[:alnum:]_]:\(';
begin

  pos := regexp_instr(str, re, 1, 1, 1);
  secName := substr( str, 1, pos - 3);
  --dbms_output.put_line('In parseSection, secName "'||secName||'"');
  --dbms_output.put_line('In parseSection, createQueryTerms from  "'||substr(str, pos-1)||'"');
  
  createQueryTerms( substr(str, pos-1), qterms, true);

end parseSection;

-- Construct a simple query string from segments (words, phrases or section searches)
-- Will find all required segments and accumulate over remaining segments

procedure simpleQuery(  
     query    in             queryTerms,
     retStr   in out nocopy  varchar2 
) is
  reqList      exprList;
  optList      exprList; 
  negList      exprList; 
  conj         varchar2(3)    := '';
  joiner       varchar2(3)    := '';
  secName      varchar2(30);
 
  sectionTerms queryTerms;
  str          varchar2(32767);
  sectionRE    varchar2(30);
  sectionName  varchar2(30);
begin
  reqList  := query.reqTerms;
  optList  := query.optTerms;
  negList  := query.negTerms;

  --dbms_output.put_line ('In simplequery');
  retStr := '';

  sectionRE := '[+-]?[[:alnum:]_]+:\(';

  if allTermsRequired then 

    if reqList.count > 0 or optList.count > 0 then
      retStr := retStr || '(';
    end if;

    if reqList.count > 0 then
      for i in 1..reqList.last loop
      --dbms_output.put_line('** Processing required term, allTerms = true');
        if regexp_instr( reqList(i), sectionRE ) = 1 then
          parseSection( reqList(i), sectionTerms, secName );
          simpleQuery( sectionTerms, str );
          retStr := retStr || conj || '((' || str || ') WITHIN '|| secName || ')';
        else
          retStr := retStr || conj || reqList(i);
        end if;
        conj := '&';
      end loop;
    end if;

    if optList.count > 0 then
      for i in 1..optList.last loop
        if regexp_instr( optList(i), sectionRE ) = 1 then
          parseSection( optList(i), sectionTerms, secName );
          simpleQuery( sectionTerms, str );
          retStr := retStr || conj || '((' || str || ') WITHIN '|| secName || ')';
        else
          retStr := retStr || conj || optList(i);
        end if;
        conj := '&';
      end loop;
    end if;

    if reqList.count > 0 or optList.count > 0 then
      retStr := retStr || ')';
    end if;

    if negList.count > 0 then
      for i in 1..negList.last loop
        if regexp_instr( negList(i), sectionRE ) = 1 then
          parseSection( negList(i), sectionTerms, secName );
          simpleQuery( sectionTerms, str );
          retStr := retStr || ' ~' || '((' || str || ') WITHIN '|| secName || ')';
        else
          retStr := retStr || ' ~' || negList(i);
        end if;
      end loop; 
    end if;
 
  else  -- allTermsRequired = false

    if reqList.count > 0 then

      retStr := retStr || '(';
      for i in 1..reqList.last loop
        if regexp_instr( reqList(i), sectionRE ) = 1 then
          parseSection( reqList(i), sectionTerms, secName );
          simpleQuery( sectionTerms, str );
          retStr := retStr || conj || '((' || str || ') WITHIN '|| secName || ')';
          --dbms_output.put_line('str: '||str);
          
        else
          retStr := retStr || conj || reqList(i);
        end if;
        conj := '&';
      end loop;
      retStr := retStr || ')';

      joiner := ' & ';
   
    end if;

    if optList.count > 0 then

      conj := '';
      retStr := retStr || joiner || '(';

      if reqList.count > 0 then

        for i in 1..reqList.last loop
          if regexp_instr( reqList(i), sectionRE ) = 1 then
            parseSection( reqList(i), sectionTerms, secName );
            simpleQuery( sectionTerms, str );
            retStr := retStr || conj || '((' || str || ') WITHIN '|| secName || ')';
          else
            retStr := retStr || conj || reqList(i);
          end if;
          conj := ',';
        end loop;

      end if;

      for i in 1..optList.last loop
        if regexp_instr( optList(i), sectionRE ) = 1 then
          parseSection( optList(i), sectionTerms, secName );
          simpleQuery( sectionTerms, str );
          retStr := retStr || conj || '((' || str || ') WITHIN '|| secName || ')';
        else
          retStr := retStr || conj || optList(i);
        end if;
        conj := ',';
      end loop;

      retStr := retStr || ')';

    end if;

    if negList.count > 0 then
      for i in 1..negList.last loop
        if regexp_instr( negList(i), sectionRE ) = 1 then
          parseSection( negList(i), sectionTerms, secName );
          simpleQuery( sectionTerms, str );
          retStr := retStr || ' ~' || '((' || str || ') WITHIN '|| secName || ')';
        else
          retStr := retStr || ' ~' || negList(i);
        end if;
      end loop; 
    end if;

  end if;

end simpleQuery;

-- Construct a query where all terms are used
-- Expect to find all standard words ANDed together 
-- and all sections where all words in section exist
-- eg if user enters
-- a b c:(d e) f
-- then we return "( a & b & f ) & ( (d & e) WITHIN c )

procedure andQuery(  
     query    in             queryTerms,
     retStr   in out nocopy  varchar2 
) is
  allList      exprList;
  reqList      exprList;
  optList      exprList; 
  negList      exprList; 
  conj         varchar2(3)    := '';
  joiner       varchar2(3)    := '';
  secName      varchar2(30);
 
  sectionTerms queryTerms;
  str          varchar2(32767);
  sectionRE    varchar2(30);
  sectionName  varchar2(30);
begin
  allList  := query.allTerms;
  reqList  := query.reqTerms;
  optList  := query.optTerms;
  negList  := query.negTerms;

  --dbms_output.put_line ('In simplequery');
  retStr := '';

  sectionRE := '[+-]?[[:alnum:]_]+:\(';

  -- All simple terms are added as a phrase search

  conj := '';

  if allList.count > 0 then
    retStr := retStr || '(';
    for i in 1..allList.last loop
      retStr := retStr || conj || allList(i);
      conj := '&';
    end loop;
    retStr := retStr || ')';

    conj := '&';

  end if;

  -- Any sections in required or optional list have to be added
  -- section contents recursively submitted to this function
  if reqList.count > 0 then
    for i in 1..reqList.last loop
      if regexp_instr( reqList(i), sectionRE ) = 1 then
        parseSection( reqList(i), sectionTerms, secName );
        andQuery( sectionTerms, str );
        retStr := retStr || conj || '((' || str || ') WITHIN '|| secName || ')';
      end if;
      conj := '&';
    end loop;
  end if;

  if optList.count > 0 then
    for i in 1..optList.last loop
      if regexp_instr( optList(i), sectionRE ) = 1 then
        parseSection( optList(i), sectionTerms, secName );
        andQuery( sectionTerms, str );
        retStr := retStr || conj || '((' || str || ') WITHIN '|| secName || ')';
      end if;
      conj := '&';
    end loop;
  end if;

  -- finally any negative terms (sections or single terms) must be added
  -- note that -a:(b +c) should only be subtracted if c is present TODO: is this right?

  if negList.count > 0 then
    if reqList.count = 0 and optList.count = 0 then 
      handleUnaryMinus();
      retStr := '';
    else
      for i in 1..negList.last loop
        if regexp_instr( negList(i), sectionRE ) = 1 then
          parseSection( negList(i), sectionTerms, secName );
          simpleQuery( sectionTerms, str );
          retStr := retStr || ' ~' || '((' || str || ') WITHIN '|| secName || ')';
        else
          retStr := retStr || ' ~' || negList(i);
        end if;
      end loop; 
    end if;
  end if;

end andQuery;

-- Construct a query where all terms are ACCUMed
-- Expect to find all standard words ACCUMed together 
-- ACCUMed with all sections where the words in the sections
-- are ACCUMed too.  Additionally we must add all required 
-- words and sections
-- eg 1 if user enters
-- a b c:(d e) f
-- then we return "(a, b, f) , ((d, e) WITHIN c)"
-- eg 2 if user enters
-- +x +y a b c:(d e) f -z
-- then we return
---(x, y, a, b, f) , ( (d, e) WITHIN c) & x & y ~z

procedure accumQuery(  
     query    in             queryTerms,
     retStr   in out nocopy  varchar2 
) is
  allList      exprList;
  reqList      exprList;
  optList      exprList; 
  negList      exprList; 
  conj         varchar2(3)    := '';
  joiner       varchar2(3)    := '';
  secName      varchar2(30);
 
  sectionTerms queryTerms;
  str          varchar2(32767);
  sectionRE    varchar2(30);
  sectionName  varchar2(30);
begin
  allList  := query.allTerms;
  reqList  := query.reqTerms;
  optList  := query.optTerms;
  negList  := query.negTerms;

  retStr := '';

  sectionRE := '[+-]?[[:alnum:]_]+:\(';

  -- All simple terms are added as a accumulated terms

  conj := '';

  retStr := retStr || '((';

  if allList.count > 0 then
    retStr := retStr || '(';
    for i in 1..allList.last loop
      retStr := retStr || conj || allList(i);
      conj := ',';
    end loop;
    retStr := retStr || ')';

    conj := ',';

  end if;

  --dbms_output.put_line('1:'||retStr);

  -- Any sections in required or optional list have to be added
  -- section contents recursively submitted to this function
  if reqList.count > 0 then
    for i in 1..reqList.last loop
      if regexp_instr( reqList(i), sectionRE ) = 1 then
        parseSection( reqList(i), sectionTerms, secName );
        --dbms_output.put_line('recurse... 1');
        accumQuery( sectionTerms, str );
        --dbms_output.put_line('end recursion, str is :'||str);
        retStr := retStr || conj || '((' || str || ') WITHIN '|| secName || ')';
      end if;
      conj := ',';
    end loop;
  end if;

  --dbms_output.put_line('2:'||retStr);

  if optList.count > 0 then
    for i in 1..optList.last loop
      if regexp_instr( optList(i), sectionRE ) = 1 then
        parseSection( optList(i), sectionTerms, secName );
        --dbms_output.put_line('recurse... 2');
        accumQuery( sectionTerms, str );
        --dbms_output.put_line('end recursion, str is :'||str);
        retStr := retStr || conj || '((' || str || ') WITHIN '|| secName || ')';
      end if;
      conj := ',';
    end loop;
  end if;

  --dbms_output.put_line('3:'||retStr);

  retStr := retStr || ')';

  -- now add any required terms

  if reqList.count > 0 then
    conj := '&';
    for i in 1..reqList.last loop
      if regexp_instr( reqList(i), sectionRE ) = 1 then
        parseSection( reqList(i), sectionTerms, secName );
        simpleQuery( sectionTerms, str );
        retStr := retStr || conj || '((' || str || ') WITHIN '|| secName || ')';
        --dbms_output.put_line('adding req section:'||str);
      else
        --dbms_output.put_line('adding req term:'||reqList(i));
        retStr := retStr || conj || reqList(i);
      end if;
    end loop;
   
  end if;

  --dbms_output.put_line('4:'||retStr);

  -- finally any negative terms (sections or single terms) must be added
  -- note that -a:(b +c) should only be subtracted if c is present TODO: is this right?

  if negList.count > 0 then
    if reqList.count = 0 and optList.count = 0 then 
      handleUnaryMinus();
      retStr := '';
    else
      for i in 1..negList.last loop
        if regexp_instr( negList(i), sectionRE ) = 1 then
          parseSection( negList(i), sectionTerms, secName );
          simpleQuery( sectionTerms, str );
          retStr := retStr || ' ~' || '((' || str || ') WITHIN '|| secName || ')';
        else
          retStr := retStr || ' ~' || negList(i);
        end if;
      end loop; 
    end if;
  end if;

  -- need to close parantheses UNLESS query zerod due to minus only query
  if length(retStr) > 0 then 
    retStr := retStr || ')';
  end if;

  --dbms_output.put_line('5:'||retStr);

end accumQuery;

-- create a NEAR query
-- eg "a b c +d e(f g) -h"
-- => NEAR((a,b,c,d)) & (NEAR((f,g)) WITHIN e) 

procedure nearQuery(  
     query    in             queryTerms,
     retStr   in out nocopy  varchar2 
) is
  allList      exprList;
  reqList      exprList;
  optList      exprList; 
  negList      exprList; 
  conj         varchar2(3)    := '';
  joiner       varchar2(3)    := '';
  secName      varchar2(30);
 
  sectionTerms queryTerms;
  str          varchar2(32767);
  sectionRE    varchar2(30);
  sectionName  varchar2(30);
begin
  allList  := query.allTerms;
  reqList  := query.reqTerms;
  optList  := query.optTerms;
  negList  := query.negTerms;

  retStr := '';

  sectionRE := '[+-]?[[:alnum:]_]+:\(';

  -- All simple terms are added as a near search

  conj := '';

  if allList.count > 0 then
    retStr := retStr || global_nearOper||'((';
    for i in 1..allList.last loop
      retStr := retStr || conj || allList(i);
      conj := ',';
    end loop;
    retStr := retStr || '))';

    conj := '&';

  end if;

  -- Any sections in required or optional list have to be added
  -- section contents recursively submitted to this function
  if reqList.count > 0 then
    for i in 1..reqList.last loop
      if regexp_instr( reqList(i), sectionRE ) = 1 then
        parseSection( reqList(i), sectionTerms, secName );
        nearQuery( sectionTerms, str );
        retStr := retStr || conj || '((' || str || ') WITHIN '|| secName || ')';
      end if;
      conj := '&';
    end loop;
  end if;

  if optList.count > 0 then
    for i in 1..optList.last loop
      if regexp_instr( optList(i), sectionRE ) = 1 then
        parseSection( optList(i), sectionTerms, secName );
        nearQuery( sectionTerms, str );
        retStr := retStr || conj || '((' || str || ') WITHIN '|| secName || ')';
      end if;
      conj := '&';
    end loop;
  end if;

  -- finally any negative terms (sections or single terms) must be added
  -- note that -a:(b +c) should only be subtracted if c is present TODO: is this right?

  if negList.count > 0 then
    if reqList.count = 0 and optList.count = 0 then 
      handleUnaryMinus();
      retStr := '';
    else
      for i in 1..negList.last loop
        if regexp_instr( negList(i), sectionRE ) = 1 then
          parseSection( negList(i), sectionTerms, secName );
          simpleQuery( sectionTerms, str );
          retStr := retStr || ' ~' || '((' || str || ') WITHIN '|| secName || ')';
        else
          retStr := retStr || ' ~' || negList(i);
        end if;
      end loop; 
    end if;
  end if;

end nearQuery;

-- proxim: all word must be present, some near to each other
-- eg "a b c +d e(f g) -h"
-- => NEAR((a,b,c,d)) & (NEAR((f,g)) WITHIN e) ~h

procedure proximQuery(  
     query    in             queryTerms,
     retStr   in out nocopy  varchar2 
) is
  allList      exprList;
  reqList      exprList;
  optList      exprList; 
  negList      exprList; 
  conj         varchar2(3)    := '';
  joiner       varchar2(3)    := '';
  secName      varchar2(30);
 
  sectionTerms queryTerms;
  str          varchar2(32767);
  sectionRE    varchar2(30);
  sectionName  varchar2(30);
begin
  allList  := query.allTerms;
  reqList  := query.reqTerms;
  optList  := query.optTerms;
  negList  := query.negTerms;

  retStr := '';

  sectionRE := '[+-]?[[:alnum:]_]+:\(';

  -- All simple terms are added as a set of NEAR pairs, accumulated together

  conj := '';

  if allList.count > 0 then

    retStr := retStr || '(';
    for i in 1..allList.last loop
      for k in i+1..(allList.last) loop
        if i != k then
          if notStopWord(allList(i)) and notStopWord(allList(k)) then 
            retStr := retStr || conj ||global_nearOper||'(('||allList(i)||','||allList(k)||'))';
            conj := ',';
          end if;
        end if;
      end loop;
    end loop;
    retStr := retStr || ')';
    conj := '&';

  end if;

  -- Any sections in required or optional list have to be added
  -- section contents recursively submitted to this function
  if reqList.count > 0 then
    for i in 1..reqList.last loop
      if regexp_instr( reqList(i), sectionRE ) = 1 then
        parseSection( reqList(i), sectionTerms, secName );
        proximQuery( sectionTerms, str );
        retStr := retStr || conj || '((' || str || ') WITHIN '|| secName || ')';
      end if;
      conj := '&';
    end loop;
  end if;

  if optList.count > 0 then
    for i in 1..optList.last loop
      if regexp_instr( optList(i), sectionRE ) = 1 then
        parseSection( optList(i), sectionTerms, secName );
        proximQuery( sectionTerms, str );
        retStr := retStr || conj || '((' || str || ') WITHIN '|| secName || ')';
      end if;
      conj := '&';
    end loop;
  end if;

  -- now add any required terms

  if reqList.count > 0 then
    conj := '&';
    for i in 1..reqList.last loop
      if regexp_instr( reqList(i), sectionRE ) = 1 then
        parseSection( reqList(i), sectionTerms, secName );
        simpleQuery( sectionTerms, str );
        retStr := retStr || conj || '((' || str || ') WITHIN '|| secName || ')';
        --dbms_output.put_line('str: '||str);
      else
        retStr := retStr || conj || reqList(i);
      end if;
    end loop;
   
  end if;

  -- finally any negative terms (sections or single terms) must be added
  -- note that -a:(b +c) should only be subtracted if c is present TODO: is this right?

  if negList.count > 0 then
    if reqList.count = 0 and optList.count = 0 then 
      handleUnaryMinus();
      retStr := '';
    else
      for i in 1..negList.last loop
        if regexp_instr( negList(i), sectionRE ) = 1 then
          parseSection( negList(i), sectionTerms, secName );
          simpleQuery( sectionTerms, str );
          retStr := retStr || ' ~' || '((' || str || ') WITHIN '|| secName || ')';
        else
          retStr := retStr || ' ~' || negList(i);
        end if;
      end loop; 
    end if;
  end if;

end proximQuery;

-- Construct a phrase query from segments (words, phrases or section searches)
-- Expect to find all standard words as a single phrase, and this phrase is 
-- ANDed with phrases within sections. eg if user enters
-- a b c:(d e) f
-- then we return "( a b f ) & ( (d e) WITHIN c )

procedure phraseQuery(  
     query    in             queryTerms,
     retStr   in out nocopy  varchar2 
) is
  allList      exprList;
  reqList      exprList;
  optList      exprList; 
  negList      exprList; 
  conj         varchar2(3)    := '';
  joiner       varchar2(3)    := '';
  secName      varchar2(30);
 
  sectionTerms queryTerms;
  str          varchar2(32767);
  sectionRE    varchar2(30);
  sectionName  varchar2(30);
begin
  allList  := query.allTerms;
  reqList  := query.reqTerms;
  optList  := query.optTerms;
  negList  := query.negTerms;

  --dbms_output.put_line ('In simplequery');
  retStr := '';

  sectionRE := '[+-]?[[:alnum:]_]+:\(';

  -- All simple terms are added as a phrase search

  conj := '';

  if allList.count > 0 then
    retStr := retStr || '(';
    for i in 1..allList.last loop
      retStr := retStr || conj || allList(i);
      conj := ' ';
    end loop;
    retStr := retStr || ')';

    conj := '&';

  end if;

  -- Any sections in required or optional list have to be added
  -- section contents recursively submitted to this function
  if reqList.count > 0 then
    for i in 1..reqList.last loop
      if regexp_instr( reqList(i), sectionRE ) = 1 then
        parseSection( reqList(i), sectionTerms, secName );
        phraseQuery( sectionTerms, str );
        retStr := retStr || conj || '((' || str || ') WITHIN '|| secName || ')';
      end if;
      conj := '&';
    end loop;
  end if;

  if optList.count > 0 then
    for i in 1..optList.last loop
      if regexp_instr( optList(i), sectionRE ) = 1 then
        parseSection( optList(i), sectionTerms, secName );
        phraseQuery( sectionTerms, str );
        retStr := retStr || conj || '((' || str || ') WITHIN '|| secName || ')';
      end if;
      conj := '&';
    end loop;
  end if;

  -- finally any negative terms (sections or single terms) must be added
  -- note that -a:(b +c) should only be subtracted if c is present TODO: is this right?

  if negList.count > 0 then
    if reqList.count = 0 and optList.count = 0 then 
      handleUnaryMinus();
      retStr := '';
    else
      for i in 1..negList.last loop
        if regexp_instr( negList(i), sectionRE ) = 1 then
          parseSection( negList(i), sectionTerms, secName );
          simpleQuery( sectionTerms, str );
          retStr := retStr || ' ~' || '((' || str || ') WITHIN '|| secName || ')';
        else
          retStr := retStr || ' ~' || negList(i);
        end if;
      end loop; 
    end if;
  end if;

end phraseQuery;

-- progQuery - generate a progressive relaxation query
-- generates steps from other xxQuery procedures
-- STEP 1 : phrase
-- STEP 2 : near (all words)
-- STEP 3 : and
-- STEP 4 : some near (proxim)
-- STEP 5 : accum

procedure progQuery (
     query    in             queryTerms,
     retStr   in out nocopy  varchar2 
) is
  allList  exprList;
  reqList  exprList;
  optList  exprList; 
  negList  exprList; 
  andStr   varchar2(5)     := '';
  joiner   varchar2(5)     := '';
  str      varchar2(32767) := '';
  str2     varchar2(32767) := '';
  re       varchar2(30);
begin
  allList := query.allTerms;
  reqList := query.reqTerms;
  optList := query.optTerms;
  negList := query.negTerms;

  -- return an empty query if nothing specified
  -- fail if required if only a negative term specified

  if reqList.count = 0 and optList.count = 0 then
    if negList.count > 0 then
      handleUnaryMinus();
    end if;
    retStr := '';
    return;
  end if;

  retStr  := '
<query>
  <textquery>
    <progression>';

  -- STEP 1 : phrase
  --          do a phrase search but boost with simple query
  --          then scores higher for multiple terms

  phraseQuery( query, str );
  simpleQuery( query, str2 );

  retStr := retStr || chr(10) || '      <seq>';
  retStr := retStr || 'DEFINEMERGE( ( (' || str || '),('|| str2 || ') ), AND, ADD )';
  retStr := retStr || '</seq>';

  -- STEP 2 : near

  nearQuery   ( query, str );
  simpleQuery ( query, str2 );

  retStr := retStr || chr(10) || '      <seq>';
  retStr := retStr || 'DEFINEMERGE( ( (' || str || '),('|| str2 || ') ), AND, ADD )';
  retStr := retStr || '</seq>';

  -- STEP 3 : and

  andQuery    ( query, str );
  simpleQuery ( query, str2 );

  retStr := retStr || chr(10) || '      <seq>';
  retStr := retStr || 'DEFINEMERGE( ( (' || str || '),('|| str2 || ') ), AND, ADD )';
  retStr := retStr || '</seq>';

  -- STEP 4 : some near (proxim)

  proximQuery( query, str );
  simpleQuery ( query, str2 );

  retStr := retStr || chr(10) || '      <seq>';
  retStr := retStr || 'DEFINEMERGE( ( (' || str || '),('|| str2 || ') ), AND, ADD )';
  retStr := retStr || '</seq>';

  -- STEP 5 : accum

  accumQuery( query, str );
  retStr := retStr || chr(10) || '      <seq>' || str || '</seq>';

  retStr := retStr || '
    </progression>
  </textquery>
  <score datatype="'||global_scoreType||'"/>
</query>';

end progQuery;

procedure strToQuery (
  queryStr      in varchar2, 
  simpleQry     in out nocopy varchar2
) is
  qTerms queryTerms;

begin

  createQueryTerms (queryStr, qTerms, true);
  simpleQuery( qTerms, simpleQry);

end strToQuery;

-- find the first regexp in a string, return string with that 
-- regexp removed, and the match itself. Also return any 
-- preceding string

procedure regexp_split 
  (str in out varchar2, match out varchar2, pattern varchar2, preceed in out varchar2) 
is
  rest     varchar2(32767) := str;
  newstart integer;
  reStart  integer;
begin
     match := regexp_substr(rest, pattern, 1, 1, 'n');
     -- find start of re
     reStart := regexp_instr(rest, pattern, 1, 1, 0, 'n');
     -- find end of re
     newStart := regexp_instr(rest, pattern, 1, 1, 1, 'n');
     preceed := substr(str, 1, reStart-1);
     str := substr(rest, newstart, length(rest)-newstart+1);
end;

-- Find end of a parenthesised string
-- start points at first open paren, we track until we reach a corresponding close
-- paren.  Can't do this in regular expressions
-- returns character position of closing paren

function  getSectionEnd( qStr in out nocopy varchar2, startPos integer ) return integer is
  pos number;
  openCount number := 0;
  closeCount number := 0;
begin
  pos := startPos;
  --dbms_output.put_line('strt pos is '||to_char(pos));
  loop 
   exit when pos > length(qStr);
    if substr(qStr, pos, 1) = '(' then
      openCount := openCount + 1;
    elsif substr(qStr, pos, 1) = ')' then
      closeCount := closeCount + 1;
    end if;
   exit when closeCount = openCount;
    pos := pos + 1;
  end loop;

  --dbms_output.put_line('end pos is '||to_char(pos));
  return pos;

end getSectionEnd;

-- find all the section searches in a query
-- a set of querySegments is returned, which is a list of simple terms 
-- (translated into Oracle Text syntax) and section searches in their 
-- original untranslated format

procedure sectionSplitter ( 
  queryText      in             varchar2,         -- query to process
  querySegments  in out nocopy queryTerms    -- list of expressions
) is

   allTerms  exprList;
   reqTerms  exprList;
   optTerms  exprList;
   negTerms  exprList;
   
   re        varchar2(255);
   qry       varchar2(32767);
   firstChar varchar2(1);

   counter integer;       -- prevent loops while testing
   loopmax integer := 9999;  --  -- "" --

   rstart    integer;     -- start of regexp marking title
   rend      integer;     -- end of regexp marking title
   secEnd    integer;     -- length of section in parens

   secQry    varchar2(4000); -- parsed section query
begin

  if querySegments.allTerms is null then 
    -- Initialise the table
    allTerms := exprList();
    reqTerms := exprList();
    optTerms := exprList();
    negTerms := exprList();
    querySegments.allTerms := allTerms;
    querySegments.reqTerms := reqTerms;
    querySegments.optTerms := optTerms;
    querySegments.negTerms := negTerms;
  end if;

  counter := 0;
 
  qry := queryText;     -- get local copy so we can change it

  -- regexp to match the start of a section search eg +sect_name:(dog cat)
  re := '[+-]?[[:alnum:]_]+:\(';
  -- loop round extracting section searches from query text
  loop

    counter := counter + 1;
    exit when counter > loopmax;

    rstart := regexp_instr(qry, re, 1, 1, 0, 'n');
   exit when rstart = 0;
    rend   := regexp_instr(qry, re, 1, 1, 1, 'n'); 

    -- find the end of the section
    secEnd   := getSectionEnd( qry, rend-1); 
 
    --dbms_output.put_line('qry is ' || chr(10) || qry);
    --dbms_output.put_line('123456789 123456789 123456789 123456789 123456789');
    --dbms_output.put_line('........10        20        30        40        50');
    --dbms_output.put_line('secEnd is ' || secEnd);
 
    firstChar := substr(qry, rstart, 1);
    --dbms_output.put_line('firstChar is '||firstChar);

    case firstChar
      when '+' then 
        querySegments.reqTerms.extend(1);
        querySegments.reqTerms(querySegments.reqTerms.last()) := 
          substr(qry, rstart + 1, secEnd - rstart);
          --dbms_output.put_line('Required section: "'||querySegments.reqTerms(querySegments.reqTerms.last())||'"');
      when '-' then
        querySegments.negTerms.extend(1);
        querySegments.negTerms(querySegments.negTerms.last()) := 
          substr(qry, rstart + 1, secEnd - rstart);
          --dbms_output.put_line('Negative section: "'||querySegments.negTerms(querySegments.negTerms.last())||'"');
      else
        querySegments.optTerms.extend(1);
        querySegments.optTerms(querySegments.optTerms.last()) := 
          substr(qry, rstart, secEnd - rstart + 1);
          --dbms_output.put_line('Optional section: "'||querySegments.optTerms(querySegments.optTerms.last())||'"');
    end case;

    -- qry now becomes the query with this section search removed
    qry := substr(qry, 1, rstart-1) || substr(qry, secEnd + 1);

    --dbms_output.put_line(qry);

  end loop;

  -- Remainder in qry is the query with all section subqueries removed.
  -- process it to extract all the simple query terms and add these
  -- to querySegments before returning it
  -- set clear = false to add rather than replace contents

  createQueryTerms( qry, querySegments, false );
  
end sectionSplitter;

procedure test is
  reqList exprList;
  ordList  exprList;
  allList  exprList;
  qry      varchar2(32767);
  query    queryTerms;
  textQ    varchar2(32767);
begin
  reqList := exprList();
  ordList  := exprList();
  allList  := exprList();

  reqList.extend();
  reqList(reqList.last()) := 'cat';
  reqList.extend();
  reqList(reqList.last()) := 'dog';

  ordList.extend();
  ordList(ordList.last()  ) := 'rabbit';

  --ordList.extend();
  --ordList(ordList.last()  ) := 'fox';

  dbms_lob.createtemporary(qry, true);
 
  query.allTerms := allList;
  query.reqTerms := reqList;
  query.optTerms := ordList;

  simpleQuery(query, qry);
  --dbms_output.put_line(qry);

  textQ := 'abc +title_sec:(foo bar) baz';
  --dbms_output.put_line(textQ);
  sectionSplitter (textQ, query);

end test;

procedure teststr(textQ varchar2) is
  query  queryTerms;
  allT   exprList;
  reqT   exprList;
  optT   exprList;
  negT   exprList;
  final  varchar2(32767);
begin

  -- Initialise the table
  allT := exprList();
  reqT := exprList();
  optT := exprList();
  negT := exprList();
  query.allTerms := allT;
  query.reqTerms := reqT;
  query.optTerms := optT;
  query.negTerms := negT;

  --dbms_output.put_line(textQ);
  --dbms_output.put_line('123456789 123456789 123456789 123456789 123456789');
  --dbms_output.put_line('........10        20        30        40        50');
  sectionSplitter (textQ, query);

  simpleQuery( query, final );
  --dbms_output.put_line ('final query is "'||final||'"');

  --for i in 1 .. query.allTerms.count() loop
    --dbms_output.put_line('ALL: "'||query.allTerms(i)||'"');
  --end loop;
  --for i in 1 .. query.reqTerms.count() loop
    --dbms_output.put_line('REQ: "'||query.reqTerms(i)||'"');
  --end loop;
  --for i in 1 .. query.optTerms.count() loop
    --dbms_output.put_line('OPT: "'||query.optTerms(i)||'"');
  --end loop;
  --for i in 1 .. query.negTerms.count() loop
    --dbms_output.put_line('NEG: "'||query.negTerms(i)||'"');
  --end loop;

end teststr;

function simpleSearch( inStr varchar2 ) return varchar2 is
  query  queryTerms;
  final  varchar2(32767);
begin

  sectionSplitter ( inStr, query );
  simpleQuery     ( query, final );
  return final;

end simpleSearch;

function phraseSearch( inStr varchar2 ) return varchar2 is
  query  queryTerms;
  final  varchar2(32767);
begin

  sectionSplitter ( inStr, query );
  phraseQuery     ( query, final );
  return final;

end phraseSearch;

function andSearch( inStr varchar2 ) return varchar2 is
  query  queryTerms;
  final  varchar2(32767);
begin

  sectionSplitter ( inStr, query );
  andQuery        ( query, final );
  return final;

end andSearch;

function nearSearch( inStr varchar2 ) return varchar2 is
  query  queryTerms;
  final  varchar2(32767);
begin

  sectionSplitter ( inStr, query );
  nearQuery       ( query, final );
  return final;

end nearSearch;

function proximSearch( inStr varchar2 ) return varchar2 is
  query  queryTerms;
  final  varchar2(32767);
begin

  sectionSplitter ( inStr, query );
  proximQuery     ( query, final );
  return final;

end proximSearch;

function accumSearch( inStr varchar2 ) return varchar2 is
  query  queryTerms;
  final  varchar2(32767);
begin

  sectionSplitter ( inStr, query );
  accumQuery      ( query, final );
  return final;

end accumSearch;

function progRelax( inStr varchar2 ) return varchar2 is
  query  queryTerms;
  final  varchar2(32767);
begin

  sectionSplitter ( inStr, query );
  progQuery       ( query, final );
  return final;

end progrelax;

procedure setMinusOnlyFail (failOption integer)
 is
begin
  if failOption = optionTrue then
    global_failMinus := TRUE;
  elsif failOption = optionFalse then
    global_failMinus := FALSE;
  else
    raise_application_error (-20706, 'Invalid option for failing on minus only: use 0 for no, 1 for yes');
  end if;
end setMinusOnlyFail;

procedure SetScoreType (scoreType integer)
 is
begin
  if scoreType = scoreTypeFloat then
    global_scoreType := 'FLOAT';
  elsif scoreType = scoreTypeInteger then
    global_scoreType := 'INTEGER';
  else
    raise_application_error (-20705, 'Invalid score type: use 0 for integer, 1 for float');
  end if;
end;

procedure UseNEAR2     (near2Option integer)
 is
begin
  if near2Option = optionTrue then 
    global_nearOper := 'NEAR2';
  elsif near2Option = optionFalse then
    global_nearOper := 'NEAR';
  else
    raise_application_error (-20702, 'Invalid NEAR2 option: use 0 for NEAR, 1 for NEAR2');
  end if;
end;

procedure SetWildCard (wildcard varchar2)
 is
begin
  if wildcard = '%' then
    global_wildcard := wildcard;
  elsif wildcard = '*' then
    global_wildcard := wildcard;
  else
    raise_application_error (-20703, 'Invalid wildcard: must be ''%'' or ''*''');
  end if;
end;

end parser;
/
-- list
show errors