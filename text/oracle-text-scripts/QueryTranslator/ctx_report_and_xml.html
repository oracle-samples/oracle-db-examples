<title>Using CTX_REPORT to generate XML output of Index Information</title>

<H3><FONT COLOR=BLUE>Using CTX_REPORT to generate XML output of Index Information</FONT></H3>

<P>
CTX_REPORT was introduced in Oracle 9i in order to help users and
Oracle Support find out information about an existing Oracle Text
index.

<P>
In Oracle 10g, CTX_REPORT has been enhanced with the option to 
produce XML output for many of its procedures. This makes it much
easier to incorporate information gained from CTX_REPORT into 
other applications - such as perhaps a custom system-monitoring
application.

<P>
This paper walks through the process of generating the report, and
processing the XML output using some of Oracle's XML capabilities.

<P>
The paper assumes a basic knowledge of Oracle Text and XML, but little
or no knowledge of Oracle's XML capabilities. It is hoped that the
paper will double as a primer on using some of Oracle's XML capabilities
to convert from XML to SQL.

<P>
The reader is strongly encouraged to try all of the examples as they are 
presented. In general, the output of the examples is <em>not</em> shown
in this document, in the assumption that the readers will be trying the
examples for themselves. You will need an Oracle 10<i>g</i> database, 
and a SQL*Plus session - no extra software or products are necessary.

<P>
The examples are run on a Text index called "TI", owned
by the user "TUSER". You could create a suitable test index by
running the following SQL as a DBA user:

<pre><font color=blue>create user tuser identified by tuser default tablespace users
  temporary tablespace temp;
grant connect,resource,ctxapp to tuser;
connect tuser/tuser
create table testtab(text varchar2(2000));
create index ti on testtab(text) indextype is ctxsys.context;
</font></pre>

- the rest of the document assumes you are running in SQL*Plus
as user TUSER.

<H3><FONT COLOR=BLUE>Getting the Total Index Size</FONT></H3>

<P>
To find out the size of the index, we can use the function
CTX_REPORT.INDEX_SIZE. This is a function returning a CLOB.  Probably
the simplest way to read it is in SQL*Plus using SELECT ... FROM DUAL,
as follows:

<pre><font color=blue>SQL> select ctx_report.index_size('ti') from dual;
</font></pre>

The chances are we'll only see a couple of lines here. That's because we need to
tell SQL*Plus to print more data, using

<pre><font color=blue>SQL> set long 50000
</font></pre>

This time when we re-run the select, we get much more text, including a final line
which says:

<pre><font color=blue>TOTAL BYTES USED:				       311,296 (304.00 KB)
</font></pre>

This is our key value. But in order to make use of that value within a program,
we'd have to fetch the output from CTX_REPORT, parse it for that final value,
then convert that value into a proper number. A lot of work.

<P>
So let's ask for an XML report instead:

<pre><font color=blue>SQL> select ctx_report.index_size('ti', null, 'XML') from dual;
</font></pre>

(note the second arg - partition name - is not needed but must be supplied since you cannot use named parameters in a function which is part of a SELECT).

<P>
This will give us a heap of XML output, including sizes for each
object.

<p>
Here's a section of the output:

<pre><font color=blue>&lt;SIZE_OBJECT_NAME&gt;
TUSER.SYS_IL0000051565C00006$$
&lt;/SIZE_OBJECT_NAME&gt;
&lt;SIZE_OBJECT_TYPE&gt;
INDEX (LOB)
&lt;/SIZE_OBJECT_TYPE&gt;
&lt;SIZE_TABLE_NAME&gt;
TUSER.DR$TI$I
&lt;/SIZE_TABLE_NAME&gt;
&lt;SIZE_TABLESPACE_NAME&gt;
USERS
&lt;/SIZE_TABLESPACE_NAME&gt;
&lt;SIZE_BLOCKS_ALLOCATED&gt;
8
&lt;/SIZE_BLOCKS_ALLOCATED&gt;
&lt;SIZE_BLOCKS_USED&gt;
4
&lt;/SIZE_BLOCKS_USED&gt;
&lt;SIZE_BYTES_ALLOCATED&gt;
65536
&lt;/SIZE_BYTES_ALLOCATED&gt;
&lt;SIZE_BYTES_USED&gt;
32768
&lt;/SIZE_BYTES_USED&gt;
&lt;/SIZE_OBJECT&gt;
&lt;SIZE_OBJECT&gt;
</font></pre>

Now for a moment let's just get the information about this on object - the $I table.
We can do this using an the XML DB extract operator, and an XPATH predicate.

<P>
To do that bit by bit:

<P>
First, rather than directly selecting a CLOB, force it into an XMLTYPE value:

<pre><font color=blue>SQL> select xmltype(ctx_report.index_size('ti', null, 'XML')) from dual;
</font></pre>

The output from this will actually be the same as before, since SQL is just converting the XMLTYPE back into a CLOB - but it prepares the way for our next step:

<P>
Next we'll use a simple XPATH expression to specify what we want to
fetch:

<pre><font color=blue>SQL> select extract(xmltype(ctx_report.index_size('ti', null, 'XML')), '//SIZE_OBJECT') from dual;
</font></pre>

We're now using the XML DB "extract" function to fetch all of the XML within &lt;SIZE_OBJECT&gt; tags. The syntax '//SIZE_OBJECT' is an XPATH expression meaning "all the XML within a SIZE_OBJECT element anywhere below the root element". A full explanation of XPATH is well beyond the scope of this document, but the reader is encouraged to look at the
<a href="http://www.w3schools.com/xpath/default.asp">tutorial at w3Schools</a>.

<P>
Notice that there are new-line characters around each element in the output. This is
actually incorrect - it's a bug.  We'll fix that now by using the SQL
"replace" function to remove all line feeds (character 10).  XMLType
will automatically reformat our XML to look OK on output.

<pre><font color=blue>select 
  extract(xmltype(replace(ctx_report.index_size('ti', null, 'XML'),chr(10),'')), 
          '//SIZE_OBJECT')
from dual;
</font></pre>


Next we just need to specify that we only want the information for the $I table. We do this with a predicate within the xpath expression:

<pre><font color=blue>select 
  extract(xmltype(replace(ctx_report.index_size('ti', null, 'XML'),chr(10),'')), 
               '//SIZE_OBJECT[SIZE_OBJECT_NAME="TUSER.DR$TI$I"]')
from dual;
</font></pre>

And to take this one stage further, we can get just the size in bytes by adding this to the XPATH expression:

<pre><font color=blue>select 
  extract(xmltype(replace(ctx_report.index_size('ti', null, 'XML'),chr(10),'')), 
               '//SIZE_OBJECT[SIZE_OBJECT_NAME="TUSER.DR$TI$I"]/SIZE_BYTES_USED')
from dual;
</font></pre>

- but we don't really want the tags - just the value. There's two ways of doing this - we can use the text() function within the XPATH, or we can use extractValue rather than extract.

<P>
Using text():

<pre><font color=blue>select 
  extract(xmltype(replace(ctx_report.index_size('ti', null, 'XML'),chr(10),'')), 
               '//SIZE_OBJECT[SIZE_OBJECT_NAME="TUSER.DR$TI$I"]/SIZE_BYTES_USED/text()')
  as "Table Size"
from dual;
</font></pre>

<pre><font color=blue>Using extractValue:
</font></pre>

<pre><font color=blue>select 
  extractValue(xmltype(replace(ctx_report.index_size('ti', null, 'XML'),chr(10),'')), 
               '//SIZE_OBJECT[SIZE_OBJECT_NAME="TUSER.DR$TI$I"]/SIZE_BYTES_USED')
  as "Table Size"
from dual;
</font></pre>

Notice we slipped in the labels "Table Size" on those two, since the column headings 
were getting increasingly unreadable.

<P>
We've now managed to extract a single value from the XML into a SQL
environment.  But what if we want to fetch ALL the sizes, perhaps to
add them together to get a summary?  To do that, we can use
XMLSequence, which returns a collection of XMLType values. We can then
use this function in a TABLE clause to unnest the collection values
into multiple rows. Now that we're generating a "table", we no longer
need to reference DUAL.

<P>
To get just the sizes:

<pre><font color=blue>select *
  from table(xmlsequence(
    extract(xmltype(replace(ctx_report.index_size('ti', null, 'XML'),chr(10),'')), 
               '//SIZE_OBJECT/SIZE_BYTES_USED')));
</font></pre>
  
To get all the object info, one object per row:

<pre><font color=blue>select * 
  from table(xmlsequence(
    extract(xmltype(replace(ctx_report.index_size('ti', null, 'XML'),chr(10),'')), 
               '//SIZE_OBJECT')));
</font></pre>

Now lets process that information into individual values:

<P>
Set the column formatting for nice output

<pre><font color=blue>column "Name" format a33
column "Tablespace" format a30
column "Bytes" format a12
</font></pre>

and do the select, using extractValue to fetch individual "columns"

<pre><font color=blue>select 
   extractValue(Column_Value, '/SIZE_OBJECT/SIZE_OBJECT_NAME') as "Name",
   extractValue(Column_Value, '/SIZE_OBJECT/SIZE_TABLESPACE_NAME') as "Tablespace",
   extractValue(Column_Value, '/SIZE_OBJECT/SIZE_BYTES_USED') as "Bytes"
   from table(xmlsequence(
    extract(xmltype(replace(ctx_report.index_size('ti', null, 'XML'),chr(10),'')), 
               '//SIZE_OBJECT')));
</font></pre>

And finally, since we've bought the values into the SQL world, we can 
use any SQL operators on the values. Here we collect the sum of all the
sizes to get an aggragate total size of all objects used in the index.

<pre><font color=blue>select 
   sum(extractValue(Column_Value, '/SIZE_OBJECT/SIZE_BYTES_USED')) "Total"
   from table(xmlsequence(
    extract(xmltype(replace(ctx_report.index_size('ti', null, 'XML'),chr(10),'')), 
               '//SIZE_OBJECT')));
</font></pre>

<H3><FONT COLOR=BLUE>INDEX_STATS</FONT></H3>

Most of the CTX_REPORT procedures have two forms - a function which returns
a CLOB (as we have been using above) and an alternate form which requires
you to pass in a CLOB to be populated. One procedure - INDEX_STATS - has does
not have a function version. This is because it needs to do a full table scan
of the main index table, which is likely to take some time. Therefore when
calling INDEX_STATS we need to go about things a little differently. First
we'll create a table with an XMLType column. Then we'll call a PL/SQL block
which passes a temporary CLOB to CTX_REPORT, and then inserts that CLOB
into the XMLType column.  We can then perform our various XML operations
on that table.

<pre><font color=blue>drop table output;
create table output(report XMLType);

declare
  tlob clob;
  begin
    ctx_report.index_stats(
       index_name=>'ti', report=>tlob, 
       list_size=>20, report_format=>'XML');
    insert into output values (xmlType (replace(tlob,chr(10),'')) );
    commit;
  dbms_lob.freetemporary(tlob);
end;
/
</font></pre>

We now have a single row in table OUTPUT, which contains our XML
report.  First we'll get the estimated row fragmentation:

<pre><font color=blue>select extractValue(report, 
         '//STAT_STATISTIC[@NAME="estimated row fragmentation"]')
       as "Fragmentation"
from output;
</font></pre>

Now something rather more complicated - get the top three most
frequent tokens. We must make a table out of the STAT_TOKEN
entries, where STAT_TOKEN_LIST has an attribute NAME equal
to "most frequent tokens" - and fetch just the first three using
the position function:

<pre><font color=blue>select extract(value(d), '//STAT_TOKEN_TEXT')
from output, table(xmlsequence(extract(report,
      '/CTXREPORT/INDEX_STATS/STAT_TOKEN_STATS/STAT_TOKEN_LIST[@NAME="most frequent tokens"]/STAT_TOKEN[position()<4]'))) d;
</font></pre>

<H3><FONT COLOR=BLUE>Conclusion</FONT></H3>

The XML output mode of CTX_REPORT allows powerful manipulation of your index information.
In order to make full use of these, you need a good understanding of the XML features of the
Oracle database, such as extract, extractValue, XMLSequence, and of XPATH syntax in general.
With the use of XML exploding within the data processing world, such an understanding is 
likely to be very useful in the future.



