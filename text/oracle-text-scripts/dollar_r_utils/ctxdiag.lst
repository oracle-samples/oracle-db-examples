SQL> @ctxdiag
drop public synonym ctx_diag
                    *
ERROR at line 1:
ORA-01432: public synonym to be dropped does not exist 


drop package ctx_diag
*
ERROR at line 1:
ORA-04043: object CTX_DIAG does not exist 


drop type KTableType
*
ERROR at line 1:
ORA-04043: object KTABLETYPE does not exist 


drop type KObjectType
*
ERROR at line 1:
ORA-04043: object KOBJECTTYPE does not exist 



Type created.


Type created.


Package created.

No errors.

Package body created.

No errors.
  1  create package body ctx_diag as
  2  
  3    type krec_typ is record(                                       -- $K row type
  4      docid   number,
  5      textkey rowid);
  6  
  7    type ktab_typ is table of krec_typ index by pls_integer;           -- $K rows
  8  
  9    c_from    varchar2(64) :=                               -- base64 from string
 10              'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
 11    c_to      varchar2(64);                                   -- base64 to string
 12  
 13    -- decode $R rowid (14 bytes base64 encoded) into string format
 14    function decode_rowid(
 15      p_hex  varchar2)
 16    return varchar2
 17    is
 18      v_str     varchar2(18);               -- uncompressed base64 encoded STRing
 19      v_rowid   varchar2(18);                -- final ROWID after base64 decoding
 20    begin
 21      for i in 0..3 loop
 22        -- char 1, 5, 9, 13
 23        v_str := v_str ||
 24          chr(trunc(to_number(substr(p_hex, 6*i + 1, 2), 'XX') / 4));
 25  
 26        -- char 2, 6, 10, 14
 27        v_str := v_str ||
 28          chr(  mod(to_number(substr(p_hex, 6*i + 1, 2), 'XX') * 16, 64) +
 29              trunc(to_number(substr(p_hex, 6*i + 3, 2), 'XX') / 16));
 30  
 31        -- char 3, 7, 11, 15
 32        v_str := v_str ||
 33          chr(  mod(to_number(substr(p_hex, 6*i + 3, 2), 'XX') * 4, 64) +
 34              trunc(to_number(substr(p_hex, 6*i + 5, 2), 'XX') / 64));
 35  
 36        -- char 4, 8, 12, 16
 37        v_str := v_str ||
 38          chr(  mod(to_number(substr(p_hex, 6*i + 5, 2), 'XX'), 64));
 39      end loop;
 40  
 41      -- base64 decode each byte
 42      v_rowid := translate(v_str, c_to, c_from);
 43  
 44      -- char 17
 45      v_rowid := v_rowid || chr(to_number(substr(p_hex, 25, 2), 'XX'));
 46  
 47      -- char 18
 48      v_rowid := v_rowid || chr(to_number(substr(p_hex, 27, 2), 'XX'));
 49  
 50      return v_rowid;
 51    end decode_rowid;
 52  
 53    -- decode $R in $K format
 54    function decode_r(
 55      p_rtab      varchar2)                                      -- $R table name
 56    return KTableType pipelined
 57    is
 58      v_cur       sys_refcursor;                                     -- $R cursor
 59      v_row       integer;                                   -- current $R row_no
 60      v_loc       blob;                                         -- $R data column
 61      v_len       integer;                                         -- BLOB LENgth
 62      v_buf       raw(14);                          -- $R compressed rowid BUFfer
 63      v_hex       varchar2(28);                        -- rowid buffer HEX string
 64      v_doc       integer := 1;                                          -- DOCid
 65      v_off       integer;                                         -- BLOB OFFset
 66      v_size      integer := 14;                                 -- $R rowid SIZE
 67    begin
 68      open v_cur for 'select row_no, data from '||p_rtab||' order by 1 asc';
 69      loop
 70        fetch v_cur into v_row, v_loc;
 71        exit when v_cur%notfound;
 72  
 73        v_off := 1;
 74        v_len := dbms_lob.getlength(v_loc);
 75        while v_off < v_len loop
 76          dbms_lob.read(v_loc, v_size, v_off, v_buf);
 77          v_hex := rawtohex(v_buf);
 78  
 79          if v_hex != '0000000000000000000000000000' then         -- skip deleted
 80            pipe row (KObjectType(v_doc, decode_rowid(v_hex)));
 81          end if;
 82  
 83          v_doc := v_doc + 1;
 84          v_off := v_off + 14;
 85        end loop;
 86      end loop;
 87      close v_cur;
 88  
 89      return;
 90    exception
 91      when others then
 92        if v_cur%isopen then
 93          close v_cur;
 94        end if;
 95        raise;
 96    end decode_r;
 97  
 98    -- write a ROWID to a given BLOB at a given offet
 99    --   If the offset is beyond the end of the data currently in the LOB,
100    --   then zero-byte fillers are inserted in the BLOB. This fact is used
101    --   to fill deleted DocIDs that are not present in $K.
102    procedure write_rowid(
103      r_loc    in out nocopy blob,
104      p_pos    integer,
105      p_rowid  varchar2)
106    is
107      v_pos    integer := p_pos;                                  -- local offset
108      v_enc    varchar2(18);                       -- base64 encoded ROWID string
109      v_int    binary_integer;
110      v_buf    raw(8);
111    begin
112      -- base64 encode each byte
113      v_enc := translate(p_rowid, c_from, c_to);
114  
115      -- for bytes 1-16 compress each 4 bytes into 3
116      --   Each byte is mapped to a 4 byte binary_integer where only the lowest
117      --   byte is not zero. When casting to RAW we use little-endian encoding
118      --   to map the lowest byte at the lowest offset (value 2 for the second
119      --   argument of cast_from_binary_integer).
120      for i in 1..4 loop
121        -- byte 1
122        v_int :=   mod(ascii(substr(v_enc, 1, 1)) *  4, 256) +
123                 trunc(ascii(substr(v_enc, 2, 1)) / 16);
124        v_buf := utl_raw.cast_from_binary_integer(v_int, 2);
125        dbms_lob.write(r_loc, 1, v_pos, v_buf);
126        v_pos := v_pos + 1;
127  
128        -- byte 2
129        v_int :=   mod(ascii(substr(v_enc, 2, 1)) * 16, 256) +
130                 trunc(ascii(substr(v_enc, 3, 1)) /  4);
131        v_buf := utl_raw.cast_from_binary_integer(v_int, 2);
132        dbms_lob.write(r_loc, 1, v_pos, v_buf);
133        v_pos := v_pos + 1;
134  
135        -- byte 3
136        v_int := mod(ascii(substr(v_enc, 3, 1)) * 64, 256) +
137                     ascii(substr(v_enc, 4, 1));
138        v_buf := utl_raw.cast_from_binary_integer(v_int, 2);
139        dbms_lob.write(r_loc, 1, v_pos, v_buf);
140        v_pos := v_pos + 1;
141  
142        v_enc := substr(v_enc, 5);
143      end loop;
144  
145      -- keep byte 17 as is
146      v_int := ascii(substr(p_rowid, 17, 1));
147      v_buf := utl_raw.cast_from_binary_integer(v_int, 2);
148      dbms_lob.write(r_loc, 1, v_pos, v_buf);
149      v_pos := v_pos + 1;
150  
151      -- keep byte 18 as is
152      v_int := ascii(substr(p_rowid, 18, 1));
153      v_buf := utl_raw.cast_from_binary_integer(v_int, 2);
154      dbms_lob.write(r_loc, 1, v_pos, v_buf);
155      v_pos := v_pos + 1;
156    end write_rowid;
157  
158    -- fill up $R row
159    --   Fill up current $R row with zeros to the maximum possible size.
160    procedure fill_row(
161      r_loc      in out blob,
162      c_max_off  integer)
163    is
164    begin
165      -- write a string that maps to all zeros into the last rowid
166      write_rowid(r_loc, c_max_off, 'AAAAAAAAAAAAAAAA'||chr(0)||chr(0));
167    end fill_row;
168  
169    -- read from $K and wrirte into $R
170    procedure k_to_r(
171      p_ktab  varchar2,
172      p_rtab  varchar2)
173    is
174      c_max       integer;                 -- maximum number of DocIDs per $R row
175      c_max_off   integer;                                      -- maximum offset
176      v_cnt       integer;                                        -- $R row CouNT
177      v_len       integer;                                  -- $R max data LENgth
178  
179      v_tab       ktab_typ;                                             -- $K row
180      v_cur       sys_refcursor;                                     -- $K cursor
181      v_prev      integer := -1;                            -- previous $R row_no
182      v_row       integer;                                   -- current $R row_no
183      v_off       integer;                             -- offset into data column
184      v_loc       blob;                                         -- $R data column
185    begin
186      -- calibrate $R
187      execute immediate
188        'select count(*), max(length(data)) from '||p_rtab
189         into v_cnt, v_len;
190      if v_cnt <= 1 then         -- empty $R is treated as regualar format (200M)
191        c_max := 200000000;
192      else                                    -- small $R row format (35K or 70K)
193        c_max := v_len / 14;
194      end if;
195      c_max_off := 14*(c_max - 1) + 1;
196      v_off := c_max_off;
197  
198      -- truncate $R
199      execute immediate
200        'truncate table '||p_rtab;
201  
202      -- read $K
203      open v_cur for 'select docid, textkey from '||p_ktab||' order by 1 asc';
204      loop
205        fetch v_cur bulk collect into v_tab limit 1000;
206  
207        -- process the batch
208        for i in 1..v_tab.count loop
209          v_row := trunc((v_tab(i).docid - 1) / c_max);
210  
211          -- init lob locator
212          while v_row > v_prev loop
213            if v_off < c_max_off then
214              fill_row(v_loc, c_max_off);         -- fill previous row with zeros
215            end if;
216            commit;
217            v_off  := 1;
218            v_prev := v_prev + 1;
219  
220            execute immediate
221              'insert into '||p_rtab||' (row_no, data) '||
222              'values (:1, empty_blob())'
223            using v_prev;
224  
225            execute immediate
226              'select data '||
227              'from  '||p_rtab||' '||
228              'where  row_no = :1 '||
229              'for update'
230            into v_loc using v_prev;
231          end loop;
232  
233          -- write rowid
234          v_off := mod(v_tab(i).docid - 1, c_max) * 14 + 1;
235          write_rowid(v_loc, v_off, v_tab(i).textkey);
236        end loop;
237  
238        -- flush the batch
239        commit;
240  
241        -- we are done
242        exit when v_cur%notfound;
243  
244        -- restart for the next batch
245        execute immediate
246          'select data '||
247          'from  '||p_rtab||' '||
248          'where  row_no = :1 '||
249          'for update'
250        into v_loc using v_prev;
251      end loop;
252      close v_cur;
253    exception
254      when others then
255        if v_cur%isopen then
256          close v_cur;
257        end if;
258        raise;
259    end k_to_r;
260  
261  begin
262    -- base64 codes
263    for i in 0..63 loop
264      c_to := c_to || chr(i);
265    end loop;
266* end ctx_diag;

Grant succeeded.


Synonym created.

SQL> quit
